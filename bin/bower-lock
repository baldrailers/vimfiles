#!/usr/bin/env node
// vim:ft=javascript

/*
 * makes a "locked" version of bower.json, where versions of `dependencies` are
 * locked to be unambiguous.
 *
 *     bower-lock lock        # create a .bowerlock file
 *     bower-lock install     # install from .bowerlock
 */

var Fs = require('fs');
var Path = require('path');
var extend = require('util')._extend;
var argv = process.argv.slice(2);

/*
 * Run
 */

if (!argv[0]) {
  console.warn("Usage: bower-lock {lock|install}");
  process.exit(1);
}
else if (argv[0] === 'lock') {
  var data = getLockfile();
  Fs.writeFileSync('.bowerlock', data);
}
else if (argv[0] === 'install') {
  installFromLockfile();
}

function installFromLockfile () {
  var exit = 0;

  run('sh', ['-c', 'mv bower.json bower.json~ && cp .bowerlock bower.json'], function (code) {
    if (code !== 0) process.exit(code);
    run('bower', ['install'], function (code) {
      exit = code;
      run('sh', ['-c', 'mv bower.json~ bower.json'], function (code) {
        process.exit(exit === 0 ? code : exit);
      });
    });
  });
}

/*
 * Run helper
 */

function run (bin, args, fn) {
  var spawn = require('child_process').spawn;
  var pid = spawn(bin, args, { stdio: 'inherit' });
  pid.on('close', fn);
}

/*
 * Get contents of lock file as a string
 */

function getLockfile () {
  var out = readJson('bower.json');
  extend(out.dependencies, out.devDependencies || {});
  extend(out.dependencies, getLockedDependencies());
  delete out.devDependencies;
  return JSON.stringify(out, null, 2) + "\n";
}

/*
 * Get locked dependencies
 */

function getLockedDependencies () {
  var dependencies = {};
  var bundlePath = getBowerPath();
  var bundles = Fs.readdirSync(bundlePath);
  var m;

  bundles.forEach(function (bundle) {
    try {
      var
        bowerFile = Path.join(bundlePath, bundle, '.bower.json'),
        data = readJson(bowerFile);

      // Read the .bower.json file
      var
        name = data.name,
        target = data._target,
        source = data._originalSource,
        res = data._resolution.type;

      // if the resolution is ambiguous, lock the commit instead
      if (res === 'branch')
        target = data._resolution.commit;
      else if (res === 'version') {
        target = data._resolution.tag;
        if (m = target.match(/^v(\d+\.\d+\.\d+)/)) target = m[1];
      }

      dependencies[name] = source + "#" + target;
    } catch (e) {}
  });

  return dependencies;
}

/*
 * Helpers
 */

function getBowerPath () {
  try {
    var bowerrc = readJson('.bowerrc');
    if (bowerrc && bowerrc.directory)
      return bowerrc.directory;
  } catch (e) {}

  return 'bower_components';
}

function readJson (file) {
  return JSON.parse(Fs.readFileSync(file, 'utf-8'));
}
